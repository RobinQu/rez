// Generated by CoffeeScript 1.6.2
(function() {
  var App, Processor, fs, http, microtime, mime, path, request, url;

  http = require("http");

  fs = require("fs");

  request = require("request");

  microtime = require("microtime");

  path = require("path");

  mime = require("mime");

  Processor = require("./processor");

  url = require("url");

  App = (function() {
    function App(port) {
      var _this = this;

      this.port = port != null ? port : 5432;
      this.root = path.resolve(__dirname, "../tmp/");
      this.processor = Processor.get();
      if (!fs.existsSync(this.root)) {
        fs.mkdirSync(this.root);
      }
      this.srv = http.createServer(function(req, res) {
        var ps;

        ps = url.parse(req.url, true);
        req.query = ps.query;
        res.error = function(e) {
          console.log("Failed to process " + req.query.source);
          res.writeHead(500);
          return res.end(e.message || e);
        };
        return _this.handle(req, res);
      });
    }

    App.prototype.start = function(fn) {
      console.log("Rez is up and running at " + this.port);
      this.srv.listen(this.port, fn);
      return this;
    };

    App.prototype.handle = function(req, res) {
      var cleanup, fp, remote, source,
        _this = this;

      source = req.query.source;
      fp = path.resolve(__dirname, "../tmp/" + microtime.now());
      remote = request(source);
      console.log(fp);
      remote.pipe(fs.createWriteStream(fp));
      setTimeout(function() {
        return res.error(new Error("Operation timeout"));
      }, 10 * 1000);
      cleanup = function() {
        if (fs.existsSync(fp)) {
          fs.unlinkSync(fp);
        }
        if (fs.existsSync("" + fp + "_processed")) {
          return fs.unlinkSync("" + fp + "_processed");
        }
      };
      remote.on("error", function(e) {
        return res.error(e);
      });
      return remote.on("end", function() {
        console.log("About to process localized file for " + source);
        return _this.processor.handle(req.query, fp, function(e, result) {
          var output;

          if (e) {
            res.error(e);
            return cleanup;
          } else {
            console.log("Process done for " + source);
            res.writeHead(200, {
              "Content-Type": mime.lookup(result.identity.format)
            });
            output = fs.createReadStream(result.dest);
            output.pip(res);
            return output.on("end", cleanup);
          }
        });
      });
    };

    App.bootstrap = function(port) {
      var app;

      if (port == null) {
        port = process.env.PORT;
      }
      return app = (new App(port)).start();
    };

    return App;

  })();

  module.exports = App;

}).call(this);
