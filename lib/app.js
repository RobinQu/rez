// Generated by CoffeeScript 1.6.2
(function() {
  var App, Processor, fs, http, microtime, mime, path, request, url;

  http = require("http");

  fs = require("fs");

  request = require("request");

  microtime = require("microtime");

  path = require("path");

  mime = require("mime");

  Processor = require("./processor");

  url = require("url");

  App = (function() {
    function App(port) {
      var _this = this;

      this.port = port != null ? port : 5432;
      this.root = path.resolve(__dirname, "../tmp/");
      this.processor = Processor.get();
      if (!fs.existsSync(this.root)) {
        fs.mkdirSync(this.root);
      }
      this.srv = http.createServer(function(req, res) {
        var ps;

        ps = url.parse(req.url, true);
        req.query = ps.query;
        res.error = function(e) {
          console.log("Failed to process " + req.query.source);
          res.writeHead(500);
          return res.end(e.message || e);
        };
        return _this.handle(req, res);
      });
    }

    App.prototype.start = function(fn) {
      console.log("Rez is up and running at " + this.port);
      this.srv.listen(this.port, fn);
      return this;
    };

    App.prototype.handle = function(req, res) {
      var cleanup, dest, extname, fp, remote, salt, source, timer,
        _this = this;

      source = req.query.source;
      extname = path.extname(source);
      salt = microtime.now();
      fp = path.resolve(__dirname, "../tmp/" + salt + extname);
      dest = path.resolve(__dirname, "../tmp/" + salt + "_processed" + extname);
      timer = setTimeout(function() {
        return res.error(new Error("Operation timeout"));
      }, 20 * 1000);
      cleanup = function() {
        console.log("cleanup...");
        if (fs.existsSync(fp)) {
          fs.unlinkSync(fp);
        }
        if (fs.existsSync(dest)) {
          return fs.unlinkSync(dest);
        }
      };
      remote = request(source);
      remote.pipe(fs.createWriteStream(fp));
      remote.on("error", function(e) {
        clearTimeout(timer);
        cleanup;
        return res.error(e);
      });
      return remote.on("end", function() {
        console.log("About to process localized file for " + source);
        return _this.processor.handle({
          parameters: req.query,
          fp: fp,
          dest: dest
        }, function(e, result) {
          var output;

          clearTimeout(timer);
          if (e) {
            res.error(e);
            return cleanup();
          } else {
            console.log("Process done for " + source);
            res.writeHead(200, {
              "Content-Type": mime.lookup(result.identity.format),
              "X-Original-Width": result.identity.width,
              "X-Original-Height": result.identity.height
            });
            output = fs.createReadStream(result.dest);
            output.pipe(res);
            return output.on("end", cleanup);
          }
        });
      });
    };

    App.bootstrap = function(port) {
      var app;

      if (port == null) {
        port = process.env.PORT;
      }
      return app = (new App(port)).start();
    };

    return App;

  })();

  module.exports = App;

}).call(this);
